<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[centos7安装mariadb集群]]></title>
    <url>%2F2019%2F03%2F07%2F190307-CentOS7%E5%AE%89%E8%A3%85Mariadb%20Galera%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[环境准备1、准备三台Centos7虚拟机环境 机器列表192.168.48.211192.168.48.212192.168.48.213 2、设置主机名（设置三台虚拟机主机名分别为node1，node2，node3）1234# vim /etc/hosts192.168.48.211 node1192.168.48.212 node2192.168.48.213 node3 3、关闭SELINUX12# setenforce 0# sed -i 's,^SELINUX=enforcing,SELINUX=disabled,g' /etc/selinux/config 4、关闭防火墙12systemctl stop firewalld.servicesystemctl disable firewalld.service 5、使用以下命令快速添加YUM源1234567# tee /etc/yum.repos.d/mariadb.repo &lt;&lt;-'EOF'[mariadb]name = MariaDBbaseurl = http://yum.mariadb.org/10.1/centos7-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1EOF 6、由于Mariadb服务器是在国外，速度较慢，可以使用国内镜像源替代，以USTC镜像源为例1# sed -i 's#yum\.mariadb\.org#mirrors.ustc.edu.cn/mariadb/yum#' /etc/yum.repos.d/mariadb.repo 7、刷新YUM缓存1# yum makecache 8、查看Mariadb相关的安装包，注意软件包版本和对应的YUM源名字1# yum list MariaDB* galera 部署MariaDB Galera集群执行yum安装命令(执行节点：node1, node2, node3)1# yum install -y MariaDB-server MariaDB-client galera 待安装完成，启动数据库，并设置root账号权限密码(执行节点：node1, node2, node3)12# systemctl start mariadb# mysql -uroot -e "grant all privileges on *.* to 'root'@'localhost' identified by 'root';flush privileges;" 也可使用如下方法设置数据库密码，测试情况使用 root % root1# /usr/bin/mysql_secure_installation 设置完成之后关闭数据库1# systemctl stop mariadb 配置node1:12345678910111213141516171819202122232425262728293031# cat /etc/my.cnf.d/server.cnf | grep -v '#'[server][mysqld][galera]wsrep_on=ONwsrep_provider=/usr/lib64/galera/libgalera_smm.sowsrep_cluster_address="gcomm://192.168.48.211,192.168.48.212,192.168.48.213"wsrep_node_name = node1binlog_format=rowdefault_storage_engine=InnoDBinnodb_autoinc_lock_mode=2bind-address=0.0.0.0wsrep_cluster_name="MariaDB_Cluster"wsrep_node_address=192.168.48.211wsrep_sst_method=rsyncwsrep_slave_threads=1innodb_flush_log_at_trx_commit=2innodb_buffer_pool_size=1024Mwsrep_sst_auth=root:root[embedded][mariadb][mariadb-10.1] 分别配置node2，node3，修改点为当前节点名称，当前节点ip地址:12345678910111213141516171819202122232425262728293031# cat /etc/my.cnf.d/server.cnf | grep -v '#'[server][mysqld][galera]wsrep_on=ONwsrep_provider=/usr/lib64/galera/libgalera_smm.sowsrep_cluster_address="gcomm://192.168.48.211,192.168.48.212,192.168.48.213"wsrep_node_name = node2binlog_format=rowdefault_storage_engine=InnoDBinnodb_autoinc_lock_mode=2bind-address=0.0.0.0wsrep_cluster_name="MariaDB_Cluster"wsrep_node_address=192.168.48.212wsrep_sst_method=rsyncwsrep_slave_threads=1innodb_flush_log_at_trx_commit=2innodb_buffer_pool_size=1024Mwsrep_sst_auth=root:root[embedded][mariadb][mariadb-10.1] 在node1上执行如下命令，启动一个集群1# /usr/sbin/mysqld --wsrep-new-cluster --user=root &amp; 查看集群状态123456789# mysql -uroot -prootMariaDB [(none)]&gt; show status like "wsrep_cluster_size";+--------------------+-------+| Variable_name | Value |+--------------------+-------+| wsrep_cluster_size | 1 |+--------------------+-------+1 row in set (0.01 sec) 在node2,node3节点上直接执行如下命令1systemctl start mariadb 再次查看集群状态，可以看到2,3节点已成功加入集群1234567MariaDB [(none)]&gt; show status like "wsrep_cluster_size";+--------------------+-------+| Variable_name | Value |+--------------------+-------+| wsrep_cluster_size | 3 |+--------------------+-------+1 row in set (0.01 sec) 集群数据同步测试在集群中任一一台主机执行如下命令1234567891011121314151617181920MariaDB [(none)]&gt; create database marspie;Query OK, 1 row affected (0.28 sec)MariaDB [(none)]&gt; use marspie;Database changedMariaDB [marspie]&gt; create table user(id int primary key,name varchar(64));Query OK, 0 rows affected (0.16 sec)MariaDB [marspie]&gt; show tables;+-------------------+| Tables_in_marspie |+-------------------+| user |+-------------------+1 row in set (0.00 sec)MariaDB [marspie]&gt; insert into user values(1,'alex');Query OK, 1 row affected (0.02 sec)MariaDB [marspie]&gt; 查看另外两台主机，我们可以发现数据已经同步了12345678910111213141516171819202122232425262728293031323334353637MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || marspie || mysql || performance_schema || test |+--------------------+6 rows in set (0.00 sec)MariaDB [(none)]&gt; use marspie;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [marspie]&gt; show tables;+-------------------+| Tables_in_marspie |+-------------------+| user |+-------------------+1 row in set (0.00 sec)MariaDB [marspie]&gt; select * from user;+----+------+| id | name |+----+------+| 1 | alex |+----+------+1 row in set (0.00 sec)MariaDB [marspie]&gt; insert into user values(2,'kiven');Query OK, 1 row affected (0.21 sec)MariaDB [marspie]&gt; 常见问题解析1、在生产环境中必须打开防火墙，如果只开放了 4567 和 针对指定ip开放3306 端口，会导致加入集群失败，需要开放3306, 4444, 4567, 4568 四个端口才可以正常启动。 2、直接kill点创建集群节点，会导致此节点无法启动 第一个启动的节点，在集群关闭数据库时需最后一个停止，再次启动集群是才可正常启动。 若第一个启动的节点被kill, 停止所有节点，再次启动第一个节点还是会启动失败，这时需进入mysql数据目录删除galera缓存文件，方可启动集群123[root@node1 ~]# cd /var/lib/mysql/[root@node1 mysql]# rm -rf grastate.dat gvwstate.dat galera.cache [root@node1 mysql]# /usr/sbin/mysqld --wsrep-new-cluster --user=root 后续如还有坑再补充！]]></content>
      <categories>
        <category>高性能架构</category>
        <category>MariaDB</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>MariaDB</tag>
        <tag>mariadb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ详解]]></title>
    <url>%2F2019%2F01%2F09%2F190109-RabbitMQ%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[初识RabbitMQRabbitMQ是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ是使用Erlang语言编写的，并且RabbitMQ是基于AMQP协议的。 目前很多互联网大厂都在使用RabbitMQ RabbitMQ底层使用Erlang语言编写 开源、性能优秀、稳定性保障 与SpringAMQP完美整合、API丰富 集群模式丰富，表达式配置，HA模式，镜像队列模式 保证数据不丢失的前提做到高可用性，高可靠性 AMQP全称：Advanced Message Queuing Protocol(高级消息队列协议) AMQP协议模型 AMQP核心概论Virtual host: 虚拟地址，用于进行逻辑隔离，最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue，同时一个Virtual Host里面不能有相同名称的Exchange和Queue Exchange: 交换机，接收消息，根据路由键转发消息到绑定的队列 Binding: Exchange和Queue之间的虚拟连接，binding中可以包含routing key Routing key: 一个路由规则，虚拟机可用它来确定如何路由一个特定消息 Queue: 也称为Message Queue，消息队列，保存消息并将它们转发给消费者 RabbitMQ消息流转 RabbitMQ整合SpringBoot2.xSpringBoot与RabbitMQ集成非常简单，不需要任何额外设置只需要两步即可： 引入相关依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.properties123456789# rabbitmq服务地址spring.rabbitmq.addresses=192.168.8.193:5672# rabbitmq用户名密码spring.rabbitmq.username=adminspring.rabbitmq.password=admin# 虚拟地址spring.rabbitmq.virtual-host=/# 超时设置spring.rabbitmq.connection-timeout=15000 代码配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package com.marspie.config;import org.springframework.amqp.core.*;import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;import org.springframework.amqp.rabbit.connection.ConnectionFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Copyright (c) 2019, The Marspie Open Source Project * 配置方法一： application.properties * 配置方法二: 代码配置ConnectionFactory * @author alex * @date 2019/1/11 11 32 * @email yaonew@126.com * @blog http://nsoft.vip * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * &lt;p&gt; * http://www.apache.org/licenses/LICENSE-2.0 * &lt;p&gt; * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */@Configurationpublic class RabbitMqConfig &#123;/* @Bean public ConnectionFactory connectionFactory() &#123; CachingConnectionFactory connectionFactory = new CachingConnectionFactory(); connectionFactory.setAddresses("192.168.48.51:5672"); connectionFactory.setUsername("admin"); connectionFactory.setPassword("admin"); connectionFactory.setVirtualHost("/"); connectionFactory.setPublisherConfirms(true);//消息确认 connectionFactory.setPublisherReturns(true); return connectionFactory; &#125;*/ //topic public static final String TOPIC_QUEUE1 = "topic.queue1"; public static final String TOPIC_QUEUE2 = "topic.queue2"; public static final String TOPIC_EXCHANGE = "topic.exchange"; // routingKey public static final String TOPIC_ROUTING_KEY1 = "order.message"; public static final String TOPIC_ROUTING_KEY2 = "order.#"; //fanout public static final String FANOUT_QUEUE1 = "fanout.queue1"; public static final String FANOUT_QUEUE2 = "fanout.queue2"; public static final String FANOUT_EXCHANGE = "fanout.exchange"; //redirect模式 public static final String DIRECT_QUEUE1 = "direct.queue1"; public static final String DIRECT_EXCHANGE = "direct.exchange"; public static final String DIRECT_QUEUE2 ="direct.queue2" ; // routingKey public static final String DIRECT_ROUTING_KEY = "direct.order"; /** * Topic模式 * 将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。 * 因此“order.#”能够匹配到“order.irs.corporate”，但是“order.*” 只会匹配到“order.irs”。 * @return */ @Bean public Queue topicQueue1() &#123; return new Queue(TOPIC_QUEUE1); &#125; @Bean public Queue topicQueue2() &#123; return new Queue(TOPIC_QUEUE2); &#125; @Bean public TopicExchange topicExchange() &#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; @Bean public Binding topicBinding1() &#123; return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(TOPIC_ROUTING_KEY1); &#125; @Bean public Binding topicBinding2() &#123; return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(TOPIC_ROUTING_KEY2); &#125; /** * Fanout模式 * Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。 * @return */ @Bean public Queue fanoutQueue1() &#123; return new Queue(FANOUT_QUEUE1); &#125; @Bean public Queue fanoutQueue2() &#123; return new Queue(FANOUT_QUEUE2); &#125; @Bean public FanoutExchange fanoutExchange() &#123; return new FanoutExchange(FANOUT_EXCHANGE); &#125; @Bean public Binding fanoutBinding1() &#123; return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange()); &#125; @Bean public Binding fanoutBinding2() &#123; return BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange()); &#125; /** * direct模式 * 消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配. * 这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “test”，则只有被标记为“test”的消息才被转发，不会转发test.aaa，也不会转发dog.bbb，只会转发test。 * @return */ @Bean public Queue directQueue1() &#123; return new Queue(DIRECT_QUEUE1); &#125; @Bean public DirectExchange directExchange() &#123; return new DirectExchange(DIRECT_EXCHANGE); &#125; @Bean public Binding directBinding1() &#123; return BindingBuilder.bind(directQueue1()).to(directExchange()).with(DIRECT_ROUTING_KEY); &#125;&#125; Topic模式将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。 因此“order.#”能够匹配到“order.irs.corporate”，但是“order.*” 只会匹配到“order.irs”。 -生产者12345678910@Componentpublic class TopicSender &#123; @Autowired private AmqpTemplate rabbitTemplate; public void send(Order order) &#123; this.rabbitTemplate.convertAndSend(RabbitMqConfig.TOPIC_EXCHANGE,"order.message", order); this.rabbitTemplate.convertAndSend(RabbitMqConfig.TOPIC_EXCHANGE,"order.ha", order); &#125;&#125; -消费者123456789101112@Componentpublic class TopicReceiver &#123; // queues是指要监听的队列的名字 @RabbitListener(queues = RabbitMqConfig.TOPIC_QUEUE1) public void receiveTopic1(Order order) &#123; System.out.println("【receiveTopic1监听到消息】" + order); &#125; @RabbitListener(queues = RabbitMqConfig.TOPIC_QUEUE2) public void receiveTopic2(Order order) &#123; System.out.println("【receiveTopic2监听到消息】" + order); &#125;&#125; Fanout模式Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。-生产者12345678910@Componentpublic class FanoutSender &#123; @Autowired private AmqpTemplate rabbitTemplate; public void send(Order order) &#123; this.rabbitTemplate.convertAndSend(RabbitMqConfig.FANOUT_EXCHANGE, "", order); &#125;&#125; -消费者1234567891011121314@Componentpublic class FanoutReceiver &#123; // queues是指要监听的队列的名字 @RabbitListener(queues = RabbitMqConfig.FANOUT_QUEUE1) public void receiveTopic1(Order order) &#123; System.out.println("【receiveFanout1监听到消息】" + order); &#125; @RabbitListener(queues = RabbitMqConfig.FANOUT_QUEUE2) public void receiveTopic2(Order order) &#123; System.out.println("【receiveFanout2监听到消息】" + order); &#125;&#125; direct模式消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配.这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “test”，则只有被标记为“test”的消息才被转发，不会转发test.aaa，也不会转发dog.bbb，只会转发test。-生产者12345678910@Componentpublic class DirectSender &#123; @Autowired private RabbitTemplate rabbitTemplate; public void send(Order order) &#123; this.rabbitTemplate.convertAndSend(RabbitMqConfig.DIRECT_EXCHANGE, "direct.order", order); &#125;&#125; -消费者1234567891011121314@Componentpublic class DirectReceiver &#123; // queues是指要监听的队列的名字 @RabbitListener(queues = RabbitMqConfig.DIRECT_QUEUE1) public void receiveDirect1(Order order) &#123; System.out.println("【receiveDirect1监听到消息】" + order); &#125; @RabbitListener(queues = RabbitMqConfig.DIRECT_QUEUE1) public void receiveDirect2(Order order) &#123; System.out.println("【receiveDirect2监听到消息】" + order); &#125;&#125; GitHub源码码云源码]]></content>
      <categories>
        <category>高性能架构</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年度账单]]></title>
    <url>%2F2018%2F12%2F30%2F181230-2018%E5%B9%B4%E5%BA%A6%E8%B4%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[好吧2018年年度账单出炉，扯点没用的，放松一下心情，拒绝沉重，保持轻松总结一下过去的2018, 下面扯蛋开始。。。 18概要2018年注定是繁忙的一年，也是值得纪念的一年，成功晋升为一名专业奶爸，成功晋升为一名资深房奴，成功… 好吧我一直走在成功的路上。 18年经济2018年大家都知道发生了贸易战，作为贸易战的牺牲者，净资产亏损15%~20%左右（好吧其实没多少钱，基金一直处于亏损状态），然后这一年也深刻的意识到买房致富不是说说，现在回想17年本打算换房（然而由于我懒的费心）。这边的经济损失大概是目前资产的一倍还多吧。 最终在18年10月左右狠下心来，贱卖（其实也谈不上贱卖，比17年还便宜几万出手了）我们现有的小房子换了套大房子（其实也不大，小三房90多平而已），不过此时的房价已经比17年涨八九千每平，达到了2万七八，更糟糕的是银行房贷利率在基准利率的基础上上调了25%，从房贷优惠9折到优惠95折再到上调10%到上调15%最终再到上调至25%仅仅只花了1年左右的时间，我们很幸运的拿到了25%。直接房价加总利息累计多花费一百多万，所以买房真的可以致富，奉劝各位想买房的一定是越早买越好。 18年家庭2018年1月份我们的小嘟宝贝出生了，从此我们从2口之家变成了3口之家，当然更多的时间是陪伴这位新成员，刚开始这个折磨人的小乖乖不肯喝母乳，要通过乳盾给他喂奶（这期间也折磨我们好久），出院后第一次体检黄疸被迫住院照蓝光，三天后出院回来小家伙的嗓子都哑了（应该是在医院哭的，好心疼），黄疸需要多晒太阳，可是一连的阴雨天压根见不着太阳，小家伙一直处于黄疸指标的边缘，生怕他又被强制住院治疗。期间吃了茵栀黄，影响了他的消化系统，好长一段时间每天都拉挺多次。后来又是咳嗽，一直揪心着。 还好慢慢的小家伙一天天长大，慢慢会爬了，会坐了，会站，看着他一天天长大，内心充满了喜悦，其实爸爸都是心比较大，这要感谢我的老婆大人时刻关注宝宝每个成长阶段的注意事项，小家伙已经快一周岁了，感觉好欣慰，家庭的温馨，给小家伙一个良好的成长环境，是我一生的事业。 18年事业2018年其实没有太大的变化，还是在原来的公司，一名标准的技术码农，然而也迷茫过，思考过，未来做什么，未来我想成为什么样的人。相信很多跟我一样的朋友很多，路在脚下吧，我还将继续探索… 展望2019啰啰嗦嗦的说了一堆。纯粹就瞎扯吧，对于19年的目标 1、 生活方面1.1 看更多的书（不局限于技术方面）1.2 装修房子 2、 事业方面2.1 提升业务技能2.2 提升技术技能2.3 完成一个秘密的小目标]]></content>
      <categories>
        <category>其他</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker之旅-Docker图形化管理和监控(二)]]></title>
    <url>%2F2018%2F12%2F20%2F181220-Docker%E4%B9%8B%E6%97%85-Docker%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%AE%A1%E7%90%86%E5%92%8C%E7%9B%91%E6%8E%A7(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[DockerUIDockerUI是一个开源的基于Docker API的web应用程序，提供等同Docker命令行的大部分功能，支持container管理，image管理, networks 管理。它最值得称道的是它华丽的设计和用来运行和管理docker的简洁的操作界面。获取首先拉去dockerUI镜像，现在dockerUI镜像1$ docker pull uifd/ui-for-docker 查看本地镜像123456789101112$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhellowpy latest d1a8a6e4b2c4 28 hours ago 131MByaonew/hellowpy v1 d1a8a6e4b2c4 28 hours ago 131MBredis latest ce25c7293564 12 days ago 95MBnginx latest 568c4670fa80 4 weeks ago 109MBpython 2.7-slim 0dc3d8d47241 5 weeks ago 120MBdocker-compose_demo latest 985f3637ded4 8 weeks ago 635MBmaven 3.5-jdk-8 985f3637ded4 8 weeks ago 635MBmysql/mysql-server 5.7 76ac6291d3cf 2 months ago 234MBhello-world latest 4ab4c602aa5e 3 months ago 1.84kBuifd/ui-for-docker latest 965940f98fa5 2 years ago 8.1MB 启动容器1$ docker run -it -d --name docker-web -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock docker.io/uifd/ui-for-docker 接着就可以在浏览器访问DockerUI管理界面了。启动了 DockerUI容器之后，就可以用它来执行启动、暂停、终止、删除以及DockerUI提供的其它操作Docker容器的命令。在浏览器里面输入 http://ip-address:9000，默认情况下登录不需要认证，但是可以配置我们的 web 服务器来要求登录认证DockerUI优点：1）支持container批量操作；2）支持image管理（虽然比较薄弱） DockerUI缺点：不支持多主机。 Shipyard入门比较遗憾目前Shipyard作者已停止维护，不过目前我们还是可以使用是一个集成管理docker容器、镜像、Registries的系统,它可以简化对横跨多个主机的Docker容器集群进行管理. 通过Web用户界面，你可以大致浏览相关信息，比如你的容器在使用多少处理器和内存资源、在运行哪些容器，还可以检查所有集群上的事件日志。其特性主要包括：1）支持节点动态集群，可扩展节点的规模（swarm、etcd方案）2）支持镜像管理、容器管理、节点管理等功能3）可视化的容器管理和监控管理4）在线容console终端 安装主节点(管理端)12345678910111213141516$ curl -s https://raw.githubusercontent.com/shipyard/shipyard-project.com/master/site/themes/shipyard/static/deploy | bash -sDeploying Shipyard -&gt; Starting Database -&gt; Starting Discovery -&gt; Starting Cert Volume -&gt; Starting Proxy -&gt; Starting Swarm Manager -&gt; Starting Swarm Agent -&gt; Starting Controller......Digest: sha256:5f065362680fa4565dd150c8da3edd09b79a7a3010d3ceef20093c2a879187e0Status: Downloaded newer image for shipyard/shipyard:latestWaiting for Shipyard on 192.168.48.244:8080Shipyard available at http://192.168.48.244:8080Username: admin Password: shipyard 登陆拉取镜像，容器启动完成。 登陆通过默认用户密码登陆系统 容器管理从容器列表看shipyard还是能支持swarm的容器的部署，填空题好费劲 容器详情 镜像管理 安裝节点在节点主机上执行如下命令，添加1$ curl -sSL https://raw.githubusercontent.com/shipyard/shipyard-project.com/master/site/themes/shipyard/static/deploy | ACTION=node DISCOVERY=etcd://192.168.48.244:4001 bash -s 执行完如上命令，我在shipyard图形化管理-&gt;节点管理中 并未显示添加的节点，不知道什么原因。 总结通过如上的使用测试，所以还凑合用吧，作者有心无力已停更，所以这个虽然能用，但是如果Docker后续更新了啥这个可能就没法支持了。 shipyard-deploy cAdvisor入门cAdvisor 是 google 开发的容器监控工具，我们来看看 cAdvisor 功能。 运行 cAdvisor 容器123456789$ docker run \ --volume=/:/rootfs:ro \ --volume=/var/run:/var/run:rw \ --volume=/sys:/sys:ro \ --volume=/var/lib/docker/:/var/lib/docker:ro \ --publish=8080:8080 \ --detach=true \ --name=cadvisor \ google/cadvisor:latest cAdvisor 会显示当前 host 的资源使用情况，包括 CPU、内存、网络、文件系统等。打开速度有点慢点击docker Containers查看运行中的容器列表点击容器连接，可以对当前容器详情进行监控cAdvisor 提供的操作界面略显简陋，而且需要在不同页面之间跳转，打开页面速度稍慢，并且只能监控一个 host，它的一大亮点是它可以将监控到的数据导出给第三方工具如Prometheus，后续继续研究。 PortainerPortainer是一个开源、轻量级Docker管理用户界面，基于Docker API，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型企业对容器管理的全部需求。 单机管理12$ docker volume create portainer_data$ docker run -d -p 9000:9000 --name portainer-test -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 执行完成浏览器访问，第一次访问设置管理员密码并登陆选择本地local确定登陆系统后可以对本地主机上的docker容器、镜像、网络进行管理本地主机docker维护 集群管理基于之前我们创建的swarm集群，我们可以很方便的将Portainer指挥艇部署在swarm集群上,并对集群进行管理，为避免之前单机测试挂载目录对下面示例的影响（导致新建的portainer无法登陆），我们先删除上面创建的挂载1$ docker volume rm portainer_data 通过stack创建服务，下载官方yaml文件，并执行12$ curl -L https://downloads.portainer.io/portainer-agent-stack.yml -o portainer-agent-stack.yml$ docker stack deploy --compose-file=portainer-agent-stack.yml portainer 浏览器访问宿主机，如上第一次设置管理员密码并登陆 对swarm集群主机stack,service,containers进行管理 swarm详情 以上实例以ubuntu18.04主机为例测试，window等其他平台安装使用参见官网文档官方演示网址：http://demo.portainer.io 账号admin 密码 tryportainer GitHub源码 参考文章https://www.portainer.io/http://dockone.io/article/1686https://portainer.readthedocs.io/https://www.fengerzh.com/portainer/]]></content>
      <categories>
        <category>微服务</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>docker</tag>
        <tag>DockerUI</tag>
        <tag>Shipyard</tag>
        <tag>cAdvisor</tag>
        <tag>Portainer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker之旅-Docker图形化管理和监控(一)]]></title>
    <url>%2F2018%2F12%2F05%2F181205-Docker%E4%B9%8B%E6%97%85-Docker%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%AE%A1%E7%90%86%E5%92%8C%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[Docker管理之官方三剑客Docker MachineDocker Machine 是 Docker 官方提供的一个工具，它可以帮助我们在远程的机器上安装 Docker，或者在虚拟机 host 上直接安装虚拟机并在虚拟机中安装 Docker。我们还可以通过 docker-machine 命令来管理这些虚拟机和 Docker。 以前你需要登录主机，按照主机及操作系统特有的安装以及配置步骤安装Docker，使其能运行Docker容器。 现在DockerMachine的产生简化了这一过程，让你可以使用一条命令在你的计算机，公有云平台以及私有数据中心创建及管理Docker主机。 安装Docker Machine在macOS和Windows上，Machine会随着Docker for Mac, Docker for Windows, 或 Docker Toolbox一起安装. 独立安装Docker Machine这里以ubuntu 18.04为例，其他系统安装参见官方文档Docker Machine123# base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp; curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp; sudo install /tmp/docker-machine /usr/local/bin/docker-machine 查看 Machine version：12# docker-machine versiondocker-machine version 0.16.0, build 702c267f 在远程主机上安装 Docker在使用 docker-machine 进行远程安装前我们需要做一些前提准备工作： 在目标主机上启用root或创建具有sudo权限的普通用户启用root ssh 登陆1234567#允许root ssh登录$ sudo -i$ sed -i -e "s/PermitRootLogin without-password/PermitRootLogin yes/g" /etc/ssh/sshd_config#重启SSH$ service ssh restart#按提示设置root用户密码$ passwd root 或者创建一个具有sudo权限的普通用户,这里以创建一个用户为例12$ sudo adduser worker1$ sudo usermod -a -G sudo worker1 配置用户ssh免密登录启用visiblepw1234$ sudo visudo#在文件前添加Defaults visiblepw#按Ctrl+O保存 Ctrl+X退出 编辑nopasswdsudo123$ vim /etc/sudoers.d/nopasswdsudo在文件中添加worker1 ALL=(ALL) NOPASSWD : ALL 把本地用户的 ssh public key 添加到目标主机上123456789101112131415161718192021222324$ ssh-copy-id -i ~/.ssh/id_rsa.pub worker1@192.168.48.202# 若用户下未生成过key,使用如下命令生成后再执行上条命令$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'.Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:xW6kJVWFItg6Lirdi7G1Jte8+lD3FaA/7BSedCICKt0 root@ubuntuThe key's randomart image is:+---[RSA 2048]----+| . o o..o. || . o .. o+... ||. o E ..+.O.o || . o. &amp; = . || ...S X . || .... = o || ..oo+ o ||. +=+oo || .o+++o. |+----[SHA256]-----+ 在本地主机执行安装命令1234567891011121314151617181920$ docker-machine create -d generic \ --generic-ip-address=192.168.48.202 \ --generic-ssh-user=worker1 \ --generic-ssh-key ~/.ssh/id_rsa \ machine-worker1Running pre-create checks...Creating machine...(machine-worker1) Importing SSH key...Waiting for machine to be running, this may take a few minutes...Detecting operating system of created instance...Waiting for SSH to be available...Detecting the provisioner...Provisioning with ubuntu(systemd)...Installing Docker...Copying certs to the local machine directory...Copying certs to the remote machine...Setting Docker configuration on the remote daemon...Checking connection to Docker...Docker is up and running!To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env machine-worker1 create 命令创建虚拟主机并安装 Docker-d –driver 的简写形式，主要用来指定使用什么驱动程序来创建目标主机另外支持的驱动详见:Machine drivers本例中使用 generic 下面以 –generic 开头的三个参数主要是指定操作的目标主机和使用的账户machine-worker1 参数是虚拟机的名称 检查安装结果123$ docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSmachine-worker1 - generic Running tcp://192.168.48.202:2376 v18.09.0 使用本地的客户端连接远程的服务器1$ eval $( docker-machine env machine-worker1) 这样就可以愉快的在本地管理远端的docker了另外docker-machine支持的命令如下：1234567891011121314151617181920212223Commands: active Print which machine is active config Print the connection config for machine create Create a machine env Display the commands to set up the environment for the Docker client inspect Inspect information about a machine ip Get the IP address of a machine kill Kill a machine ls List machines provision Re-provision existing machines regenerate-certs Regenerate TLS Certificates for a machine restart Restart a machine rm Remove a machine ssh Log into or run a command on a machine with SSH. scp Copy files between machines mount Mount or unmount a directory from a machine with SSHFS. start Start a machine status Get the status of a machine stop Stop a machine upgrade Upgrade a machine to the latest version of Docker url Get the URL of a machine version Show the Docker Machine version or a machine docker version help Shows a list of commands or help for one command 对于远程管理来说，SSH 的支持是必不可少的！Docker Machine 当然也尽职尽责的完成了任务：1$ docker-machine ssh machine-worker1 执行上面的命令，瞬间穿越至目标主机，双击666 Docker ComposeDocker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速在集群中部署分布式应用。实际项目中我们不可能就一个docker容器走天下，正常都是要多个容器合作完成任务，如果我们一个一个容器去启动，势必很麻烦头大，docker-compose 可以解决我们的问题，下面简单实例以springboot服务+mysql数据库服务项目结构如下， demo 是我们的springboot web工程 mysql目录，可以加一下针对mysql的配置 docker-compose.yaml 猪脚，描述如何构建整个服务 docker-compose.yaml 配置文件12345678910111213141516171819202122232425262728version: '3'services: mysql: container_name: demo-mysql image: mysql/mysql-server:5.7 volumes: - ./mysql/data:/var/lib/mysql environment: MYSQL_DATABASE: demo MYSQL_ROOT_PASSWORD: root MYSQL_ROOT_HOST: '%' ports: - "3306:3306" restart: always demo: restart: always build: ./demo working_dir: /demo volumes: - /etc/localtime:/etc/localtime:ro - ./demo:/demo - ~/.m2:/root/.m2 ports: - "8080:8080" depends_on: - mysql command: mvn clean spring-boot:run -Dspring-boot.run.profiles=docker version: ‘3’： 表示使用第三代语法来构建 docker-compose.yaml 文件。 services: 用来表示 compose 需要启动的服务，我们可以看出此文件中有2个服务分别为：mysql、demo。 container_name: 容器名称 environment: 此节点下的信息会当作环境变量传入容器，此示例中 mysql 服务配置了数据库、密码和权限信息。 ports: 表示对外开放的端口 restart: always 表示如果服务启动不成功会一直尝试。 volumes: 加载本地目录下的配置文件到容器目标地址下 depends_on：可以配置依赖服务，表示需要先启动 depends_on 下面的服务后，再启动本服务。 command: mvn clean spring-boot:run -Dspring-boot.run.profiles=docker: 表示以这个命令来启动项目，-Dspring-boot.run.profiles=docker表示使用 application-docker.properties文件配置信息进行启动。 Spring Boot 项目配置在demo 目录下也就是和pom.xm文件同级添加Dockerfile文件，文件内容如下：1FROM maven:3.5-jdk-8 只要这一句，依赖于基础镜像maven3.5和jdk1.8。因为在docker-compose.yaml文件设置了项目启动命令，这里不需要再添加启动命令 application-docker.properties 添加针对于docker的配置：1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://mysql:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=root 项目部署以下命令在docker-compose.yaml 同级目录执行启动服务：1docker-compose up --build 停止服务:1docker-compose down 查看项目中目前的所有容器1docker-compose ps 就是这么简单。 项目GitHub源码 Docker SwarmSwarm是Docker官方提供的一款集群管理工具，其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。Swarm和Kubernetes比较类似，但是更加轻，具有的功能也较kubernetes更少一些。Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。 Docker Swarm的获取从Docker(1.12版本以后) swarm 已整体集成在Docker Engine中，这里我们只讨论新版本中docker swarm的使用 创建一个Swarm的集群详细参数参见官方文档https://docs.docker.com/engine/reference/commandline/swarm_init/#options，1docker swarm init [OPTIONS] 12345678$ docker swarm init --listen-addr 0.0.0.0:2377 --advertise-addr 192.168.48.244Swarm initialized: current node (unegtfborf8ldmn41h89rttzf) is now a manager.To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-2j9t0uf0a442hks10f4l4bp9fz01j5wkr81twl3mgjyl6fuvva-5i1itkmhe4tehzbqhas4wztns 192.168.48.244:2377To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions. –listen-addr 指出的是这个集群暴露给外界调用的HTTPAPI的socket地址–advertise-addr 标志配置了管理节点的 IP 地址。如果你的机器只有一张网卡，可以省略。 Swarm的集群管理向Swarm的集群中添加节点分别在第二台、第三台主机上执行以上生成的 docker swarm join –token命令12345678910# 输出添加一个worker节点命令$ docker swarm join-token workerTo add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-2j9t0uf0a442hks10f4l4bp9fz01j5wkr81twl3mgjyl6fuvva-5i1itkmhe4tehzbqhas4wztns 192.168.48.244:2377# 输出添加一个manager节点命令$ docker swarm join-token managerTo add a manager to this swarm, run the following command: docker swarm join --token SWMTKN-1-2j9t0uf0a442hks10f4l4bp9fz01j5wkr81twl3mgjyl6fuvva-0f54w8ra5ldg27b8yjwe4kg9r 192.168.48.244:2377 为了不用登陆到每台主机中去执行docker swarm join –token命令，这样太麻烦，我们可以结合上面的docker-machine 命令使用，通过docker-machine create添加两台远程主机1234$ docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSmachine-worker1 - generic Running tcp://192.168.48.202:2376 v18.09.0 machine-worker2 - generic Running tcp://192.168.48.203:2376 v18.09.0 分别将machine-worker1，machine-worker2 作为一个节点添加到swarm集群，执行如下命令1234$ docker-machine ssh machine-worker1 "sudo docker swarm join --token SWMTKN-1-2j9t0uf0a442hks10f4l4bp9fz01j5wkr81twl3mgjyl6fuvva-5i1itkmhe4tehzbqhas4wztns 192.168.48.244:2377"This node joined a swarm as a worker.$ docker-machine ssh machine-worker2 "sudo docker swarm join --token SWMTKN-1-2j9t0uf0a442hks10f4l4bp9fz01j5wkr81twl3mgjyl6fuvva-5i1itkmhe4tehzbqhas4wztns 192.168.48.244:2377"This node joined a swarm as a worker. 无需登录远程主机，这样两个节点就添加进swarm集群了，查看下当前swarm集群中的节点12345$ docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION53bbepypujpr5qi5zzspre7el * master Ready Active Leader 18.09.0bifyoaqegffgcmooulu749co5 worker1 Ready Active 18.09.0d94ktuzewdxl9nkszbibilj24 worker2 Ready Active 18.09.0 这样我们就得到了一个由三个节点组成的小集群，manager本身也自动作为worker一员加入集群 节点更新12$ docker node update --availability drain worker2worker2 可以手动将某个节点的可用性设置为Drain或者active，比如这里将名为worker2的节点设置为drain了之后，可以看到在docker node ls 中出现的新信息12345$ docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION53bbepypujpr5qi5zzspre7el * master Ready Active Leader 18.09.0bifyoaqegffgcmooulu749co5 worker1 Ready Active 18.09.0d94ktuzewdxl9nkszbibilj24 worker2 Ready Drain 18.09.0 删除节点执行命令 docker swarm leave –force这里我们将worker2节点从swarm 集群中移除：12$ docker-machine ssh machine-worker2 "sudo docker swarm leave --force" Node left the swarm. 构建服务在swarm集群中，管理节点是集群中唯一可以执行命令的机器，或授权其他机器作为manager加入群集,worker只是在那里提供服务能力，并且没有权力告诉任何其他机器它能做什么和不能做什么，为了构建下面的集群服务，我们再次执行上面的添加节点操作把worker2节点添加进集群。12$ docker-machine ssh machine-worker2 "sudo docker swarm join --token SWMTKN-1-2j9t0uf0a442hks10f4l4bp9fz01j5wkr81twl3mgjyl6fuvva-5i1itkmhe4tehzbqhas4wztns 192.168.48.244:2377"This node joined a swarm as a worker. 在管理节点执行构建服务命令：1234567891011121314$ docker service create -p 4000:80 --replicas 5 --name helloswarm yaonew/hellowpy:v1image yaonew/hellowpy:v1 could not be accessed on a registry to recordits digest. Each node will access yaonew/hellowpy:v1 independently,possibly leading to different nodes running differentversions of the image.h926sud2306kg0lirv0dcydwyoverall progress: 5 out of 5 tasks 1/5: running [==================================================&gt;] 2/5: running [==================================================&gt;] 3/5: running [==================================================&gt;] 4/5: running [==================================================&gt;] 5/5: running [==================================================&gt;] verify: Service converged docker service create 命令创建服务-p 端口映射，将容器80端口映射到宿主机4000端口上–name 标志将服务命名为helloswarm–replicas 标志指定了期望状态为 5 个运行示例yaonew/hellowpy:v1 镜像 这里使用了自己构建的镜像 查看服务列表123$ docker service lsID NAME MODE REPLICAS IMAGE PORTSh926sud2306k helloswarm replicated 5/5 yaonew/hellowpy:v1 查看服务详情12345678910111213$ docker service ps helloswarm ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSkderyu36u33v helloswarm.1 yaonew/hellowpy:v1 worker2 Running Running 15 minutes ago quly9g70410v helloswarm.2 yaonew/hellowpy:v1 master Running Running 15 minutes ago frzcgbjkogia helloswarm.3 yaonew/hellowpy:v1 worker2 Running Running 15 minutes ago jr7xux73fpmo helloswarm.4 yaonew/hellowpy:v1 master Running Running 15 minutes ago xpqar72dplms helloswarm.5 yaonew/hellowpy:v1 worker1 Running Running 15 minutes ago ``` 可以看到swarm集群根据算法将期望运行的5个实例分别运行在master、worker1、worker2上，通过浏览器访问http://192.168.48.244:4000 可以看出swarm自动为我们做了负载均衡，每个请求，以循环方式选择5个实例中的一个来响应。##### 伸缩服务``` bash$ docker service scale helloswarm=10 通过以上命令可以迅速将helloswarm服务提升至10个实例，之前已经启动的5个实例不受影响，将新构建5个实例，查看服务详情。123456789101112$ docker service ps helloswarm ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSvhyxlovgvjdj helloswarm.1 yaonew/hellowpy:v1 worker1 Running Running 9 minutes ago my8fv4gf5pxg helloswarm.2 yaonew/hellowpy:v1 worker2 Running Running 9 minutes ago x8p9nuqpmz0p helloswarm.3 yaonew/hellowpy:v1 master Running Running 9 minutes ago zlx5o9m7jyyf helloswarm.4 yaonew/hellowpy:v1 worker1 Running Running 9 minutes ago 4rbcagnwqn4t helloswarm.5 yaonew/hellowpy:v1 worker2 Running Running 9 minutes ago tv4x55ihaq7q helloswarm.6 yaonew/hellowpy:v1 master Running Running 24 seconds ago wvr1dys8psg0 helloswarm.7 yaonew/hellowpy:v1 master Running Running 22 seconds ago u7uz9lq8l2cd helloswarm.8 yaonew/hellowpy:v1 master Running Running 23 seconds ago xyt77whcy911 helloswarm.9 yaonew/hellowpy:v1 worker2 Running Running 30 seconds ago ldi0b1atvzz2 helloswarm.10 yaonew/hellowpy:v1 worker1 Running Running 30 seconds ago 删除swarm上的服务1$ docker service rm helloswarm 通过YAML文件构建服务YAML文件，用于定义Docker容器在生产中的行为方式，yaonew/hellowpy:v1 我们自己的镜像，请确保已推送到远程仓库，下面新建docker-compose.yml文件 12345678910111213141516171819version: "3"services: web: # replace username/repo:tag with your name and image details image: yaonew/hellowpy:v1 deploy: replicas: 5 resources: limits: cpus: "0.1" memory: 50M restart_policy: condition: on-failure ports: - "4000:80" networks: - webnetnetworks: webnet: 这个docker-compose.yml文件告诉Docker执行以下操作：从注册中心中提取镜像。以此镜像运行5个实例作为一个服务，服务名为web，限制每个实例使用最多10％的CPU（所有核心）和50MB的RAM。如果如果容器出错，立即重启。将主机上的端口4000映射到Web的端口80。指示Web容器通过称为webnet的负载平衡网络共享端口80。默认使用Webnet网络（负载平衡网络）。 通过yaml文件省去了在命令行添加太多参数的烦恼，运行服务123$ docker stack deploy -c docker-compose.yml helloswarmCreating network helloswarm_webnetCreating service helloswarm_web 这里创建了一个网络名称为：helloswarm_webnet 创建了一个服务名称：helloswarm_web查看服务详情1234567docker service ps helloswarm_web ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSv3tzalw6trzg helloswarm_web.1 yaonew/hellowpy:v1 worker2 Running Starting 8 seconds ago xa37injkdiov helloswarm_web.2 yaonew/hellowpy:v1 master Running Starting 4 seconds ago y81yo07gzsl7 helloswarm_web.3 yaonew/hellowpy:v1 worker1 Running Running less than a second ago 2ujbxosbiu2z helloswarm_web.4 yaonew/hellowpy:v1 worker2 Running Starting 8 seconds ago 1fa0jsr09v5i helloswarm_web.5 yaonew/hellowpy:v1 master Running Starting 4 seconds ago 查看容器信息1234# 各主机查看启动容器id$ docker container ls -q# 查看所有容器$ docker ps -a 扩展应用我们可以通过更改docker-compose.yml文件，并重新运行docker stack deploy命令来扩展应用程序：123456docker stack deploy -c docker-compose.yml helloswarmUpdating service helloswarm_web (id: xa3th1y6lwz45ca3c0dpgu872)image yaonew/hellowpy:v1 could not be accessed on a registry to recordits digest. Each node will access yaonew/hellowpy:v1 independently,possibly leading to different nodes running differentversions of the image. Docker执行就地更新，无需杀死任何容器。现在，重新运行docker container ls -q以查看已重新配置的已部署实例。 如果增加实例数量，则会启动更多任务，从而启动更多容器。 清理退出123docker stack rm helloswarm Removing service helloswarm_webRemoving network helloswarm_webnet 项目GitHub源码 参考文章https://docs.docker.com/machine/overview/http://blog.51cto.com/hashlinux/1772507https://www.cnblogs.com/sparkdev/p/7044950.htmlhttps://docs.docker.com/compose/overview/https://docs.docker.com/engine/reference/commandline/swarm/https://www.cnblogs.com/franknihao/p/8490416.htmlhttps://blog.csdn.net/u011936655/article/details/81147315]]></content>
      <categories>
        <category>微服务</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>docker</tag>
        <tag>Shipyard</tag>
        <tag>cAdvisor</tag>
        <tag>Portainer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令备忘录]]></title>
    <url>%2F2018%2F11%2F29%2F181129-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[备忘教程learngitbranching.js.org. 克隆远程仓库项目1$ git clone https://gitee.com/marspie/git-training.git 修改提交123456789101112131415$ cd git-training$ echo "test" &gt;&gt; a.txt$ git add .$ git commit -m "test commit"$ git push -u origin masterEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 4 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 274 bytes | 137.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: Powered by Gitee.comTo https://gitee.com/marspie/git-training.git 83f8711..f49cd75 master -&gt; masterBranch 'master' set up to track remote branch 'master' from 'origin'. 分支查看当前分支信息12345678$ git branch* master$ git statusOn branch masterYour branch is up to date with 'origin/master'.nothing to commit, working tree clean 创建远程分支1、新建本地分支123456$ git checkout -b devSwitched to a new branch 'dev'$ git branch* dev master 星号(*)表示当前所在分支。现在的状态是成功创建的新的分支并且已经切换到新分支上。 2、把新建的本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）12345$ git push origin dev:devTotal 0 (delta 0), reused 0 (delta 0)remote: Powered by Gitee.comTo https://gitee.com/marspie/git-training.git * [new branch] dev -&gt; dev 3、查看所有分支1$ git branch -a 4、切换分支1$ git checkout master 删除远程分支1、推送一个空分支到远程分支，其实就相当于删除远程分支：1$ git push origin :dev 2、也可以使用1234$ git push origin --delete devremote: Powered by Gitee.comTo https://gitee.com/marspie/git-training.git - [deleted] dev 删除本地分支12$ git branch -d devDeleted branch dev (was f49cd75). 分支合并dev分支的工作成果合并到master分支上123456$ git merge devUpdating f49cd75..b7c3423Fast-forward dev.txt | Bin 0 -&gt; 12 bytes 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 dev.txt Git回退查看 git 日志123456789101112131415161718$ git log -3commit b9efa3bb30dfe635e40f42ec6a45ada0e06b4712 (HEAD -&gt; dev2)Author: yaonew &lt;yaonew@126.com&gt;Date: Thu Nov 29 14:33:25 2018 +0800 dev2 modifycommit a262f949bbd3fe881e6c5ecdc5c0bb2735b0d8c7 (origin/dev2)Author: yaonew &lt;yaonew@126.com&gt;Date: Thu Nov 29 14:31:01 2018 +0800 dev2 commitcommit b7c342333b482ea3f3b9c3b0231d26fd322ec326 (origin/dev, dev)Author: yaonew &lt;yaonew@126.com&gt;Date: Thu Nov 29 14:19:07 2018 +0800 dev branch 回退到指定版本1$ git reset --hard a262f949bbd3fe881e6c5ecdc5 强制提交1$ git push -f origin dev2 参考https://blog.csdn.net/yeputi1015/article/details/80571204https://www.cnblogs.com/wancy86/p/5848024.htmlhttps://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000https://www.cnblogs.com/wangmingshun/p/5425150.html]]></content>
      <categories>
        <category>协作</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一台电脑多个github账号设置]]></title>
    <url>%2F2018%2F07%2F21%2F180721-%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[如何在一台电脑上使用多个github账号，由于之前已经配置过一个github账号，最近又注册了了一个账号，显然现在多账号的问题出现在自己面前，于是就扒了下多账号的设置。希望对遇到同样问题的你有一点帮助。 生成多个SSH Key进入用户家目录Windows 使用Git Bash, Linux 打开terminal. 各系统对应的目录位置如下：Windows目录: C:\Users\用户名.sshLinux\Mac目录：~/.ssh 1ssh-keygen -t rsa -C email 输入如上命令，email 替换成需要生成key的邮箱回车，由于是多账号，我们需要修改默认的id_rsa 文件的名称，这里我们加上后缀，标实不同的github账号，输入密码部分可以留空或输入，若输入密码后续git push到远程仓库时均需输入此处设置的密码,方便起见我们使用ssh-agent（详见下文），回车若看到如下图所示，表示生成ssh key 成功了，重复如上操作生成多个ssh key。进入用户家目录下的.ssh文件目录下，可以看到我们生成的多组key, id_rsa id_rsa.pub分别对应私钥与公钥 配置Config文件为了让git知道我们用哪个账号提交，这里需要配置config文件，在当前家目录 .ssh文件夹下新建config文件，配置如下内容： 1234567891011121314# 配置github1Host yaonew.com # 自定义的host简称 HostName github.com # 主机名可用ip也可以是域名 IdentityFile C:\\Users\\peeka\\.ssh\\id_rsa_yaonew # 证书文件路径 # 认证方式 可以设为 publickey,password publickey,keyboard-interactive PreferredAuthentications publickey User git # 登录用户名# 配置github2Host marspie.com HostName github.com IdentityFile C:\\Users\\peeka\\.ssh\\id_rsa_marspie PreferredAuthentications publickey User git 配置完以上信息后，git clone的链接应修改为如下: 1234567# 原始clone 地址git@github.com:yaonew/test1.gitgit@github.com:marspie/test2.git# 新clone地址git@yaonew.com:yaonew/test1.gitgit@marspie.com:marspie/test2.git 登陆Github添加公钥分别登陆两个github账号，进入Settings –&gt; SSH and GPG keys，拷贝~/.ssh 下.pub公钥文件内容添加至github SSH连接测试12ssh -T git@github.comssh -T git@marspie.com 当看到如上信息时测试成功，同时远端github的钥匙已变成绿色 本地git设置这样设置过就OK了吗，显然不行，由于之前使用过一个github账号，并设置了全局git账号，这里需要移除1234567891011# 原有全局账号设置git config --golbal user.name &quot;name&quot;git config --golbal user.email &quot;xxx@qq.com&quot;#全局配置账户、邮箱已经移除git config --global --unset user.namegit config --global --unset user.email#查看全局用户名、全局邮箱git config --global user.namegit config --global user.email 然后在具体的工程目录下设置用户及邮箱 12git config user.name yaonewgit config user.email yaonew@126.com 分别做相应账号工程下做相应修改并提及 ssh-agent因为我们生成ssh key设置了密码，每次git push 认证时都需要输入密码，显然这不是我们希望的，ssh-agent是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 打开 ssh-agent1234# github官方的bashssh-agent -s# 其它，比如msysgiteval $(ssh-agent -s) 添加私钥添加秘钥时输入密码后续的认证就交由ssh-agent了，直接提交丝般顺滑 ^_^ 12ssh-add ~/.ssh/id_rsa_yaonewssh-add ~/.ssh/id_rsa_marspie 愉快的多账号之旅开始了。。。]]></content>
      <categories>
        <category>协作</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Linux</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务从入门到放弃之概述]]></title>
    <url>%2F2017%2F10%2F12%2F171012-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E4%B9%8B%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[前言微服务真的很火，很新，很潮，很多人说到微服务都能侃侃而谈，各种新鲜的名词、概念、框架止不住地蹦出来，但是：什么时候应当实行微服务呢？实行微服务应当要注意些什么呢？，首先我们了解下新生的微服务架构与传统架构有哪些区别。 传统架构单体架构Web应用发展早期，大部分Web工程将所有的功能模块打包到一起后放到Web容器中运行，很多企业的Jave应用程序打包成war,ear 它们的主要特点： 一个程序包包含了应用所有功能， 通常称之为单体应用。 架构单体应用的架构风格， 我们称之为单体架构， 这是一种比较传统的架构风格。 单体架构缺点 复杂性逐渐变高 - 由于业务的不断修改深入，系统变得越来越庞大，复杂度越来越高。 技术债务逐渐上升 - 参与项目的人员流动，水平不同，人员往往会埋坑，问题没有得到解决，坑越来越多。 部署速度逐渐变慢 - 业务模块增多，代码量不断增多，部署启动速度相应的越来越慢。 阻碍技术创新 - 技术在发展，历史的架构选型注定了系统形态，新的模块需求依然需要使用老旧的技术。 无法按需伸缩（出现IO或CPU瓶颈时需要兼顾或妥协） 微服务架构微服务是什么lMartin Fowler：简而言之，微服务架构风格这种开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统的。其中每个小型服务都运行在自己的进程中，并经常采用HTTP资源API这样轻量的机制来相互通信。这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。对这些微服务我们仅做最低限度的集中管理。来自：http://www.martinfowler.com/articles/microservices.html 微服务解决了什么微服务特性 每个微服务可独立运行在自己的进程里； 一系列独立运行的微服务共同构建起了整个系统； 每个服务为独立的业务开发，一个微服务一般完成某个特定的功能，比如：订单管理、用户管理等； 微服务之间通过一些轻量的通信机制进行通信，例如通过REST API或者RPC的方式进行调用。 微服务的优点 启动较快 局部修改容易部署 技术栈不受限 按需伸缩 DevOps 微服务带来的挑战 边界清晰 - 软件架构开发中如何合理的划分边界，边界清晰和技术限制之间做出权衡 运维要求较高 - 服务之间相互依赖运维需要清晰的知道服务之间的依赖关系 分布式的复杂性 - 分布式系统固有的复杂性，网络问题，完整的监控，如何保持一致性，事务保障，高可用性等等 接口调整成本高 - 一个服务接口的调整可能涉及到多服务需要同时调整 重复劳动 - 一个个微服务既然名曰”服务”，就得五脏俱全，就得螺蛳壳里做道场, 麻雀虽小五脏全该有的基础功能数据库的访问，工具类使用，IO处理，网络，各个服务里面都得处理。 微服务设计原则 单一职责原则-[Single Responsible Principle] ，即每个服务只做一件事，并把这件事做好； 服务自治原则- 每个微服务需要有自己独立的开发、测试、部署、运维。 轻量级通信原则 - 通讯协议需要跨平台，跨语言，不要绑定技术栈。 接口明确原则 - 一个微服务接口的修改可能相关联的微服务也需要跟着修改，这时需要提前规划好，避免接口修改 总论总的来说，从传统架构到SOA再到微服务架构，微服务带来了很多全新的东西，可以解决传统架构的一些问题，但同时对系统的架构技术也提出的更高的要求，实现微服务也需要一定的前提条件，，我们不能一味的认为微服务架构好。微服务这种分开当家当然潇洒，但要知道自己当家也有自己的累。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker之旅-使用阿里云Docker镜像库加速]]></title>
    <url>%2F2017%2F09%2F15%2F170915-Docker%E4%B9%8B%E6%97%85-%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91Docker%E9%95%9C%E5%83%8F%E5%BA%93%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[使用阿里云Docker镜像库加速官方的docker hub 访问实在太慢，国内使用阿里云Docker镜像库,可以大大加快镜像的下载速度，访问Docker镜像库开通了阿里云开发者帐号，进入管理中心，获取您的专属加速器地址。 根据操作文档，选择对应您的操作系统，目前提供了Ubuntu、CentOS、Window、Mac系统的操作说明: 一、Ubuntu安装／升级你的Docker客户端推荐安装1.10.0以上版本的Docker客户端。或执行以下命令： 1curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - 使用Docker加速器针对Docker客户端版本大于1.10的用户，可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://z8b39a7q.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 二、CentOS安装／升级你的Docker客户端推荐安装1.10.0以上版本的Docker客户端。您可以通过阿里云的镜像仓库下载：docker-ce或执行以下命令：123456789101112131415161718192021222324252627282930313233curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -``` ### 如何使用Docker加速器针对Docker客户端版本大于1.10的用户您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器：``` bashsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://z8b39a7q.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker``` ## 三、Window### 安装／升级你的Docker客户端 1. 对于Windows 10以下的用户 推荐使用 Docker Toolbox Toolbox的介绍和帮助：mirrors.aliyun.com/help/docker-toolbox Windows系统的安装文件目录：http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/ 2. 对于Windows 10以上的用户 推荐使用 Docker for Windows Windows系统的安装文件目录：http://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/### 如何使用Docker加速器1. 创建一台安装有Docker环境的Linux虚拟机，指定机器名称为default，同时配置Docker加速器地址。``` bashdocker-machine create --engine-registry-mirror=https://z8b39a7q.mirror.aliyuncs.com -d virtualbox default``` 2. 查看机器的环境配置，并配置到本地，并通过Docker客户端访问Docker服务。``` bashdocker-machine env defaulteval "$(docker-machine env default)"docker info 注意 Docker for Windows 和 Docker Toolbox是不兼容，如果同时安装两者的话，需要使用hyperv的参数启动。 1docker-machine create --engine-registry-mirror=https://z8b39a7q.mirror.aliyuncs.com -d hyperv default Docker for Windows 有两种运行模式，一种运行Windows相关容器，一种运行传统的Linux容器。同一时间只能选择一种模式运行。 四、Mac安装／升级你的Docker客户端1. 对于10.10.3以下的用户 推荐使用 Docker Toolbox Toolbox的介绍和帮助：mirrors.aliyun.com/help/docker-toolbox Mac系统的安装文件目录：http://mirrors.aliyun.com/docker-toolbox/mac/docker-toolbox/ 2. 对于10.10.3以上的用户 推荐使用 Docker for Mac Mac系统的安装文件目录：http://mirrors.aliyun.com/docker-toolbox/mac/docker-for-mac/ 如何使用Docker加速器 创建一台安装有Docker环境的Linux虚拟机，指定机器名称为default，同时配置Docker加速器地址。docker-machine create --engine-registry-mirror=https://z8b39a7q.mirror.aliyuncs.com -d virtualbox default 查看机器的环境配置，并配置到本地，并通过Docker客户端访问Docker服务。docker-machine env default eval "$(docker-machine env default)" docker info 设置完成，接着我们再试下pull一个镜像，是不是有种飞起来的赶脚O(∩_∩)O~]]></content>
      <categories>
        <category>微服务</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker之旅-Docker互联]]></title>
    <url>%2F2017%2F09%2F11%2F170911-Docker%E4%B9%8B%E6%97%85-Docker%E4%BA%92%E8%81%94%2F</url>
    <content type="text"><![CDATA[Docker的互联方式 基于Volume的互联 基于Link的互联 基于网络的互联 基于Volume的互联在docker run 启动一个容器的时候，我们可以通过设置 -v 参数将宿主机目录映射到容器目录，这样容器对映射路径下数据的修改即使在容器被删除的情况下，数据还能够保留。进入learn目录，在此目录下创建 一个文件夹查看容器详情，在Mounts 节点我们可以看到/learn 目录对应的宿主机目录，进入：/var/lib/docker/volumes/858c12a2fed04733b27256ae57a1f76455e9f0030182ad405bf5fd5aa049c54d/_datadocker inspect 4bc0f1e4a005查看宿主机的目录，我们可以发现我们在容器中创建的 testvolume 文件夹目录可以多个容器中的Volume指向宿主机的同一个目录，实现基于文件的的共享访问基于容器数据的的单主机互联 基于Link的互联启用一个mysql docker 容器 docker run --rm=true --name=marspiedb -e MYSQL_ROOT_PASSWORD=123456 mysql 查看我们创建的marspiedb 详细信息 # docker inspect marspiedb Docker默认允许container互通，通过-icc=false关闭互通。一旦关闭了互通，只能通过-link name:alias命令连接指定container.– link redis:db的别名，会在/etc/hosts中生成对应的ip映射Link跨主机的互联,使用 Docker远程代理（Ambassador）模式，https://github.com/gliderlabs/connectablesocat是一个多功能的网络工具，名字来由是”Socket CAT” 基于网络的互联 最常用的方式端口映射，将docker端口映射到宿主机，直接通过宿主机IP：映射端口 访问docker run --rm=true --name=marspiedb -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql 直接使用宿主机网络docker run --rm=true --net=host --name=marspiedb -e MYSQL_ROOT_PASSWORD=123456 mysql 容器共用一个IP地址docker run --rm=true --name=marspiedb -e MYSQL_ROOT_PASSWORD=123456 mysql docker run --rm=true --net=container:marspiedb java ip addr 同一个IP 使用localhost 就可以很愉快的访问(⊙o⊙)哦]]></content>
      <categories>
        <category>微服务</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker之旅-Docker镜像制作]]></title>
    <url>%2F2017%2F07%2F25%2F170725-Docker%E4%B9%8B%E6%97%85-Docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[制作自己的Docker镜像制作自己的Docker镜像有两种方式 将容器变成镜像 通过Buildfile语法制作镜像 将容器变成镜像首先我们先从docker镜像仓库拉取一个tomcat镜像，切换到root账号123456789# docker search tomcatNAME DESCRIPTION STARS OFFICIAL AUTOMATEDtomcat Apache Tomcat is an open source implementa... 1419 [OK] tomee Apache TomEE is an all-Apache Java EE cert... 38 [OK] dordoka/tomcat Ubuntu 14.04, Oracle JDK 8 and Tomcat 8 ba... 37 [OK]davidcaste/alpine-tomcat Apache Tomcat 7/8 using Oracle Java 7/8 wi... 19 [OK]consol/tomcat-7.0 Tomcat 7.0.57, 8080, "admin/admin" 16 [OK]cloudesire/tomcat Tomcat server, 6/7/8 15 [OK].... 这里会列出镜像仓库 中一堆的tomcat相关的镜像资源，下面我们拉取一个到本地。12345# docker pull dordoka/tomcat//等待一段时间拉取完成# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdordoka/tomcat latest 7d9888a99efb 7 months ago 780 MB 启动容器12345678910111213141516171819# docker run -it -p 8080:8080 dordoka/tomcat//查看所有容器# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9a987406fc9e dordoka/tomcat "/opt/tomcat/bin/c..." 2 minutes ago Up About a minute 8009/tcp, 0.0.0.0:8080-&gt;8080/tcp flamboyant_darwin// 下面我们进入容器，做一些修改# docker exec -it 9a987406fc9e /bin/bashroot@9a987406fc9e:/opt/tomcat# cd webappsroot@9a987406fc9e:/opt/tomcat/webapps# lshost-manager manager// 接下来在webapps目录下创建一个ROOT目录，并在里面新建一个index.html页面root@9a987406fc9e:/opt/tomcat/webapps# mkdir ROOTroot@9a987406fc9e:/opt/tomcat/webapps# cd ROOT/root@9a987406fc9e:/opt/tomcat/webapps/ROOT# touch index.html// 在Html页面写些内容，比如 Hello World!root@9a987406fc9e:/opt/tomcat/webapps/ROOT# vi index.html // 编辑完退出 containerroot@9a987406fc9e:/opt/tomcat/webapps/ROOT# exitexit 在宿主机上通过浏览器访问 http://localhost:8080 就能看到我们对于容器的修改。 将我们修改好的容器制作成镜像通过docker commit [repo:tag] 将容器制作成镜像1234567# docker commit 9a987406fc9e marspie/tomcat:1.0sha256:8887c9ac97bc3f3fc5767bf714f058035f4f89cd24162a57844140d755a505a1//查看本地镜像，可以看到我们制作好的marspie/tomcat 1.0版# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmarspie/tomcat 1.0 8887c9ac97bc 49 seconds ago 780 MBdordoka/tomcat latest 7d9888a99efb 7 months ago 780 MB 将容器制作成镜像的做法： 优点缺点最方便，最快速不规范，无法自动化 Buildfile 制作镜像下面我们通过Buildfile文件来制作一个jdk1.8-tomcat8的镜像。 首先我们从Oracle官网下载: jdk-8u144-linux-x64.tar.gz 下载Tomcat8 Apache官网下载：apache-tomcat-8.5.16.tar.gz Buildfile 文件内容如下 123456789101112131415161718192021222324252627282930# VERSION 0.0.1# ubuntu server FROM ubuntu# 签名MAINTAINER MARSPIE "marspie@126.com"# 把java与tomcat添加到容器中 ADD jdk-8u144-linux-x64.tar.gz /usr/local/ADD apache-tomcat-8.5.16.tar.gz /usr/local/# 配置java与tomcat环境变量 ENV JAVA_HOME /usr/local/jdk1.8.0_144ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV TOMCAT_HOME /usr/local/apache-tomcat-8.5.16 ENV PATH $PATH:$JAVA_HOME/bin:$TOMCAT_HOME/lib:$TOMCAT_HOME/bin # 容器运行时监听的端口 EXPOSE 8080 ENTRYPOINT ["/usr/local/apache-tomcat-8.5.16/bin/catalina.sh", "run"]#CMD /usr/local/apache-tomcat-8.5.16/bin/catalina.sh run``` 4. 将如上准备的3个文件至于同一目录下``` bash[root@bogon docker]# ls -ltotal 190372-rwxrw-rw-. 1 alex alex 9417469 Jul 30 18:28 apache-tomcat-8.5.16.tar.gz-rw-------. 1 alex alex 654 Jul 30 19:09 Dockerfile-rwxrw-rw-. 1 alex alex 185515842 Jul 30 18:34 jdk-8u144-linux-x64.tar.gz 使用如下命令制作镜像 123456789101112131415161718192021222324252627282930313233[root@bogon docker]# docker build -t marspie/ubuntu-tomcat8:0.0.2 .Sending build context to Docker daemon 194.9 MBStep 1/10 : FROM ubuntu ---&gt; 14f60031763dStep 2/10 : MAINTAINER MARSPIE "marspie@126.com" ---&gt; Using cache ---&gt; 9e2681f280b5Step 3/10 : ADD jdk-8u144-linux-x64.tar.gz /usr/local/ ---&gt; Using cache ---&gt; e69764710ed4Step 4/10 : ADD apache-tomcat-8.5.16.tar.gz /usr/local/ ---&gt; Using cache ---&gt; 9cef7a3e804bStep 5/10 : ENV JAVA_HOME /usr/local/jdk1.8.0_144 ---&gt; Using cache ---&gt; 54b3e6339868Step 6/10 : ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ---&gt; Using cache ---&gt; 463ccbe97778Step 7/10 : ENV TOMCAT_HOME /usr/local/apache-tomcat-8.5.16 ---&gt; Using cache ---&gt; 9455c2777e34Step 8/10 : ENV PATH $PATH:$JAVA_HOME/bin:$TOMCAT_HOME/lib:$TOMCAT_HOME/bin ---&gt; Using cache ---&gt; 5fc99c79cfe5Step 9/10 : EXPOSE 8080 ---&gt; Using cache ---&gt; 63aa2690221fStep 10/10 : ENTRYPOINT /usr/local/apache-tomcat-8.5.16/bin/catalina.sh run ---&gt; Running in ef7da9894470 ---&gt; 55eebdf6b21dRemoving intermediate container ef7da9894470Successfully built 55eebdf6b21d 运行下我们制作的tomcat镜像 1# docker run -it -p 8080:8080 55eebdf6b21d 测试，通过宿主机浏览器访问：http://localhost:8080 看到tomcat的欢迎页面，好了通过Dockerfile制作镜像成功了。 Docker 镜像的导入导出将镜像导出为文件1# docker save -o marspie-ubuntu-tomcat8.0.02.tar marspie/ubuntu-tomcat8:0.0.2 完成后通过 ls 命令即可看到文件 将我们打包导出的镜像包上传至另一台虚机镜像导入1# docker load -i marspie-ubuntu-tomcat8.0.02.tar 这样我们又可以在这台虚机愉快的玩耍了O(∩_∩)O~]]></content>
      <categories>
        <category>微服务</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 16.04 LTS RabbitMQ 3.6.10 安装配置]]></title>
    <url>%2F2017%2F06%2F21%2F170621-ubuntu-16-04-LTS-RabbitMQ-3-6-10-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[RabbitMQ 安装配置RabbitMQ 已经经历了10 来个春夏秋冬，全球超过35000生产部署RabbitMQ，RabbitMQ是最受欢迎的开源消息队列，正如官网的介绍： RabbitMQ is the most widely deployed open source message broker With more than 35,000 production deployments of RabbitMQ world-wide at small startups and large enterprises, RabbitMQ is the most popular open source message broker. RabbitMQ 安装 访问RabbitMQ官网 下载对应系统版本，这里我们下载Debian Ubuntu 对应的版本。 将下载的rabbitmq-server_3.6.10-1_all.deb 安装包放于用户家目录下work目录。 12345alex@ubuntu:~$ cd work/alex@ubuntu:~/work$ ls -ltotal 4772-rwxrw-rw- 1 alex alex 4885200 Jun 21 01:29 rabbitmq-server_3.6.10-1_all.debalex@ubuntu:~/work$ 使用 dpkg 命令安装 rabbitmqdpkg 参见：Ubuntu下deb包的安装方法 1234567891011121314151617181920alex@ubuntu:~/work$ sudo dpkg -i rabbitmq-server_3.6.10-1_all.deb [sudo] password for alex: Selecting previously unselected package rabbitmq-server.(Reading database ... 208585 files and directories currently installed.)Preparing to unpack rabbitmq-server_3.6.10-1_all.deb ...Unpacking rabbitmq-server (3.6.10-1) ...dpkg: dependency problems prevent configuration of rabbitmq-server: rabbitmq-server depends on erlang-nox (&gt;= 1:16.b.3) | esl-erlang; however: Package erlang-nox is not installed. Package esl-erlang is not installed. rabbitmq-server depends on socat; however: Package socat is not installed.dpkg: error processing package rabbitmq-server (--install): dependency problems - leaving unconfiguredProcessing triggers for man-db (2.7.5-1) ...Processing triggers for systemd (229-4ubuntu10) ...Processing triggers for ureadahead (0.100.0-19) ...Errors were encountered while processing: rabbitmq-server 如上rabbitmq-server依赖于erlang-nox，下面安装输入：sudo apt-get install erlang-noxbut 依然报错12345678910111213141516171819202122232425262728293031323334alex@ubuntu:~/work$ sudo apt-get install erlang-noxReading package lists... DoneBuilding dependency tree Reading state information... DoneYou might want to run 'apt-get -f install' to correct these:The following packages have unmet dependencies: erlang-nox : Depends: erlang-base but it is not going to be installed or erlang-base-hipe but it is not going to be installed Depends: erlang-asn1 but it is not going to be installed Depends: erlang-corba but it is not going to be installed Depends: erlang-crypto but it is not going to be installed Depends: erlang-diameter but it is not going to be installed Depends: erlang-edoc but it is not going to be installed Depends: erlang-eldap but it is not going to be installed Depends: erlang-erl-docgen but it is not going to be installed Depends: erlang-eunit but it is not going to be installed Depends: erlang-ic but it is not going to be installed Depends: erlang-inets but it is not going to be installed Depends: erlang-mnesia but it is not going to be installed Depends: erlang-odbc but it is not going to be installed Depends: erlang-os-mon but it is not going to be installed Depends: erlang-parsetools but it is not going to be installed Depends: erlang-percept but it is not going to be installed Depends: erlang-public-key but it is not going to be installed Depends: erlang-runtime-tools but it is not going to be installed Depends: erlang-snmp but it is not going to be installed Depends: erlang-ssh but it is not going to be installed Depends: erlang-ssl but it is not going to be installed Depends: erlang-syntax-tools but it is not going to be installed Depends: erlang-tools but it is not going to be installed Depends: erlang-webtool but it is not going to be installed Depends: erlang-xmerl but it is not going to be installed rabbitmq-server : Depends: socat but it is not going to be installedE: Unmet dependencies. Try 'apt-get -f install' with no packages (or specify a solution). 根据提示，执行 apt-get -f install中途提示：Do you want to continue? [Y/n] 输入 Y1234567891011121314151617181920212223242526272829303132333435alex@ubuntu:~/work$ sudo apt-get -f installReading package lists... DoneBuilding dependency tree Reading state information... DoneCorrecting dependencies... DoneThe following additional packages will be installed: erlang-asn1 erlang-base erlang-corba erlang-crypto erlang-diameter erlang-edoc erlang-eldap erlang-erl-docgen erlang-eunit erlang-ic erlang-inets erlang-mnesia erlang-nox erlang-odbc erlang-os-mon erlang-parsetools erlang-percept erlang-public-key erlang-runtime-tools erlang-snmp erlang-ssh erlang-ssl erlang-syntax-tools erlang-tools erlang-webtool erlang-xmerl libodbc1 libsctp1 socatSuggested packages: erlang erlang-manpages erlang-doc xsltproc fop erlang-ic-java erlang-observer libmyodbc odbc-postgresql tdsodbc unixodbc-bin lksctp-toolsThe following NEW packages will be installed: erlang-asn1 erlang-base erlang-corba erlang-crypto erlang-diameter erlang-edoc erlang-eldap erlang-erl-docgen erlang-eunit erlang-ic erlang-inets erlang-mnesia erlang-nox erlang-odbc erlang-os-mon erlang-parsetools erlang-percept erlang-public-key erlang-runtime-tools erlang-snmp erlang-ssh erlang-ssl erlang-syntax-tools erlang-tools erlang-webtool erlang-xmerl libodbc1 libsctp1 socat0 upgraded, 29 newly installed, 0 to remove and 326 not upgraded.1 not fully installed or removed.Need to get 19.6 MB of archives.After this operation, 36.9 MB of additional disk space will be used.Do you want to continue? [Y/n] Y....Adding system user `rabbitmq' (UID 124) ...Adding new user `rabbitmq' (UID 124) with group `rabbitmq' ...Not creating home directory `/var/lib/rabbitmq'.Setting up libsctp1:amd64 (1.0.16+dfsg-3) ...Processing triggers for libc-bin (2.23-0ubuntu9) ...Processing triggers for systemd (229-4ubuntu10) ...Processing triggers for ureadahead (0.100.0-19) ... 再次输入：sudo dpkg -i rabbitmq-server_3.6.10-1_all.deb12345678alex@ubuntu:~/work$ sudo dpkg -i rabbitmq-server_3.6.10-1_all.deb (Reading database ... 210659 files and directories currently installed.)Preparing to unpack rabbitmq-server_3.6.10-1_all.deb ...Unpacking rabbitmq-server (3.6.10-1) over (3.6.10-1) ...Setting up rabbitmq-server (3.6.10-1) ...Processing triggers for man-db (2.7.5-1) ...Processing triggers for systemd (229-4ubuntu10) ...Processing triggers for ureadahead (0.100.0-19) ... 显然如上结果，表示 rabbitmq-server 安装完成，启动rabbitmq-server 服务123456// 启动 rabbitmq-serveralex@ubuntu:~/work$ sudo service rabbitmq-server start// 停止 rabbitmq-serveralex@ubuntu:~/work$ sudo service rabbitmq-server stop// 重启 rabbitmq-serveralex@ubuntu:~/work$ sudo service rabbitmq-server restart 若通过终端安装程序sudo apt-get install xxx时出错：123sudo apt-get install erlang-noxE: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it 通过如下强制解锁,命令1$ sudo rm /var/lib/dpkg/lock 再次输入安装命令，可能会会提示 “E: dpkg 被中断，您必须手工运行 sudo dpkg –configure -a 解决此问题”按照提示执行：sudo dpkg –configure -a RabbitMQ 管理插件 management pluginRabbitMQ 默认已经集成了management plugin，通过命令enable即可123456789101112$ cd /usr/lib/rabbitmq/bin/$ sudo rabbitmq-plugins enable rabbitmq_managementThe following plugins have been enabled: amqp_client cowlib cowboy rabbitmq_web_dispatch rabbitmq_management_agent rabbitmq_managementApplying plugin configuration to rabbit@ubuntu... started 6 plugins...... 当显示如上信息，打开浏览器访问：http://localhost:15672输入默认用户名/密码：guest/guest 登陆Web管理页： guest用户只能从localhost地址登录，如果要配置远程登录，必须创建用户 通过Web管理页面添加用户并设置权限，点击用户进入授权页面，默认直接点击”set permission”即可 通过命令添加用户,并分配权限：123456$ sudo rabbitmqctl add_user admin adminCreating user "admin"$ sudo rabbitmqctl set_user_tags admin administratorSetting tags for user "admin" to [administrator]$ sudo rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"Setting permissions for user "admin" in vhost "/" 设置完成后，RabbitMQ就可以远程通过 http://rabbitmq_ip:15672 访问了。]]></content>
      <categories>
        <category>高性能架构</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error: Module version mismatch. Expected 48, got 46.]]></title>
    <url>%2F2017%2F06%2F05%2F170605-Error-Module-version-mismatch-Expected-48-got-46%2F</url>
    <content type="text"><![CDATA[Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。 Hexo Admin Plugin 是可以为Hexo提供后台管理的插件，今天安装了一下hexo-admin的修改版：hexo-admin-qiniu进入之前安装的blog目录 123456789101112131415161718192021$ npm install --save hexo-admin-qiniu.....$ hexo server -dError: Module version mismatch. Expected 48, got 46. at Error (native) at Object.Module._extensions..node (module.js:597:18) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/hexo-log/node_modules/bunyan/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo-cli/node_modules/hexo-log/node_modules/bunyan/lib/bunyan.js:79:18) 错误提示模块的版本不匹配，可能是因为hexo版本 与很多模块更新不匹配了,尝试删除所有模块，重新安装无果 $ rm -rf node_modules $ npm install 所以我们重新安装配置下Hexo,解决方法：执行以下代码： $ npm install hexo --no-optional $ npm install hexo-cli -g npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules/hexo-cli/node_modules/bluebird npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules/hexo-cli/node_modules/chalk/node_modules/has-ansi/node_modules/ansi-regex npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules/hexo-cli/node_modules/chalk/node_modules/strip-ansi/node_modules/ansi-regex npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-fs/node_modules/chokidar/node_modules/anymatch/node_modules/micromatch/node_modules/arr-diff/node_modules/arr-flatten .... npm ERR! Darwin 16.6.0 npm ERR! argv "/usr/local/bin/node" "/usr/local/bin/npm" "install" "hexo-cli" "-g" npm ERR! node v6.10.1 npm ERR! npm v3.10.10 npm ERR! path /usr/local/lib/node_modules/hexo-cli/node_modules/bluebird npm ERR! code EACCES npm ERR! errno -13 npm ERR! syscall access npm ERR! Error: EACCES: permission denied, access '/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird' npm ERR! at Error (native) npm ERR! { Error: EACCES: permission denied, access '/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird' npm ERR! at Error (native) npm ERR! errno: -13, npm ERR! code: 'EACCES', npm ERR! syscall: 'access', npm ERR! path: '/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird' } npm ERR! npm ERR! Please try running this command again as root/Administrator. npm ERR! Please include the following file with any support request: npm ERR! /Users/alex/Projects/blog/npm-debug.log 分析错误由于权限问题，重新执行 $ sudo npm install --unsafe-perm --verbose -g hexo Password: .... 安装完成，执行启动hexo $ hexo server -d INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 启动正常，浏览器访问：http://localhost:4000/admin 现在可以愉快的写博客了]]></content>
      <categories>
        <category>其他</category>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac之Git账号的坑]]></title>
    <url>%2F2017%2F06%2F04%2F170604-Mac%E4%B9%8BGit%E8%B4%A6%E5%8F%B7%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Permission to xxx/xxxxx.git denied to username.之前使用mac终端中的git时，输入了用户名和密码，现在换了新的用户名密码后，clone下来的代码，修改后push 却提示 remote: Permission to marspie/marspie-demo.git denied to yaonew.fatal: unable to access ‘https://github.com/marspie/marspie-demo.git/&#39;: The requested URL returned error: 403 其中yaonew是我第一次使用的用户名，现在已经使用了新的用户了。尝试重新 ssh-keygen 生成密钥，github添加新的密钥，无果。 经过网络搜索，有提出同样问题的，但是回复寥寥无几且没有能真正解决问题的，于是变化思路查找：Mac多Git账号配置，找到了一个帖子：http://suqianghotel.com/2016/09/13/mac-mulit-git-account-config/ 在文章的末尾找到了GitHub 官网的帮助文档：GitHub help Updating credentials from the OSX KeychainYou’ll need to update your saved username and password in the git-credential-osxkeychain helper if you change your password or username on GitHub. Updating your credentials via Keychain Access In Finder, search for the Keychain Access app. In Keychain Access, search for github.com. Find the “internet password” entry for github.com. Edit or delete the entry accordingly. Deleting your credentials via the command lineThrough the command line, you can use the credential helper directly to erase the keychain entry. To do this, type the following command: $ git credential-osxkeychain erase host=github.com protocol=https [Press Return] If it’s successful, nothing will print out. To test that it works, try and clone a repository from GitHub. If you are prompted for a password, the keychain entry was deleted. 重新 git push$ git push origin master Username for 'https://github.com': marspie Password for 'https://marspie@github.com': Counting objects: 8, done. Delta compression using up to 8 threads. Compressing objects: 100% (8/8), done. Writing objects: 100% (8/8), 628 bytes | 0 bytes/s, done. Total 8 (delta 5), reused 0 (delta 0) remote: Resolving deltas: 100% (5/5), completed with 5 local objects. To https://github.com/marspie/marspie-demo.git 32fe0cd..0a71a8a master -&gt; master OK 搞定， tag!]]></content>
      <categories>
        <category>协作</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker之旅-Docker入门]]></title>
    <url>%2F2017%2F04%2F09%2F170409-Docker%E4%B9%8B%E6%97%85-Docker%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Docker组件 (C/S架构) docker client ：Docker客户端 docker server ：Docker daemon 主要组成部分 接收client 请求 并按照路由规则实现路由分发 docker image : docker 镜像运行之后变成容器（docker run） docker registry: registry是docker镜像的中央存储仓库（pull /push） Docker镜像构建1$ docker build -t registry_url/namespace/marspie/centos:7.1[latest] .[.代表Dockerfile在当前路径下] 运行容器Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG…]docker run -it (交互模式) —name base marspie/centos:7.1 -d 后端运行 -p host_point：container_point -P 随机分配端口映射 -v host_dir:container_dir 容器目录与宿主机目录映射 查看所有container12$ docker ps （只能查看UP状态的container）$ docker ps -a 进入docker容器只有UP状态的docker容器可以进入访问1$ docker exec -it website(container_id/container_name) /bin/bash 退出1$ exit 删除docker容器1$ docker rm -f(强制删除) 名字/id 停止docker容器123$ docker stop （container_id/container_name）# 停止所有容器$ docker stop $(docker ps -qa) 查看所有镜像1$ docker images 删除镜像1$ docker rmi (image_id/image_name)]]></content>
      <categories>
        <category>微服务</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thinking change 2017]]></title>
    <url>%2F2017%2F03%2F27%2F170327-Thinking-change-2017%2F</url>
    <content type="text"><![CDATA[2017年已过三个月，作为程序猿、码农的IT群中的一员，是该抽空思考下… 一平时有空喜欢逛下头条，这张职业规范图中是否有一天发展路线适合我，值得思考，虽然现在还处于E象限，I象限是我的终极目标了，呵呵！ 二读书，显然读书能增加个人的知识面，当然不能只局限于工作相关的书籍，其他领域也要多涉及，正如一位牛人所说，如何让别人觉得你牛逼呢，跟JAVA的开发聊PHP，跟PHP的开发聊JAVA, 跟python的开发人员聊c++，那如果聊天的对象都懂点呢？ 那就跟他聊历史O(∩_∩)O哈哈~，所以要让自己在别人眼中牛逼，各方面知识都要有所涉及。当然现在这种知识飞速发展的时代，真正能静下心来看书主动学习的人并不是很多，我们可以借用别人的大脑学习，各种听书的APP，总归听比看方便多少，以及别人的一些领会，可以都我们的学习有一点启发。2017时刻提醒自己多读些书。 三运动，有个好的身体才能更好的学习，生活，工作，每个星期至少运动个两到三次吧，打打球、跑跑步、爬爬山都可以，该行动了，为了改变，以前太懒，现在为了更好的自己，我需要这么做。 四创作，拓展自己的思维，发布一些作品，比如一个开源项目，创作一本漫画，或者作为自媒体多写些文章，创作来源于生活，是的我应该好好生活，提高自己从现在开始。 五程序猿的世界往往比较简单，不是在coding,就是在去coding的路上，丰富自己的生活，尝试一些跨界的事物，增加一些兴趣爱好，学学书法，让自已这颗浮躁的心安静下来。 2017 为了更好的自己thinking change.]]></content>
      <categories>
        <category>其他</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文档书写工具-gitbook介绍]]></title>
    <url>%2F2017%2F03%2F25%2F170325-%E6%96%87%E6%A1%A3%E4%B9%A6%E5%86%99%E5%B7%A5%E5%85%B7-gitbook%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是gitbookgitbook 是基于Node.js的命令行工具，可以使用github、git Markdown 书写电子书，可以作为自己知识的积累，书写API文档，将平时学习生活中的文字记录，出版电子书等等。 gitbook安装gitbook基于Node.js所以第一步安装Node.js的支持，访问Nodejs官网下载对应版本安装 验证安装打开命令行终端 $ node -v v6.10.1 若能打印出Nodejs版本，表示安装成功 gitbook命令行安装$ npm install -g gitbook-cli 安装完成接着输入 gitbook -V 查看版本 $ gitbook -V CLI version: 2.3.0 gitbook 常用命令//初始化图书 $ gitbook init //生成html，生成路径图书文件目录下_book文件夹 $ gitbook build //网页浏览器查看图书 $ gitbook serve //linux下可生成pdf文件，需安装pdf依赖 $ npm install gitbook-pdf -g $ gitbook pdf gitbook客户端 GitBook Editor有了gitbook客户端可以方便的管理书写我们的电子书，官方下载GitBook Editor 总得使用下来感受还可以，初始化打开启动稍慢，gitbook文档与GitHub可以实现同步，简单一个按钮 publish&amp;Sync 可以将文档保存至gitbook以及同步至GitHub，perfect。]]></content>
      <categories>
        <category>其他</category>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[170324-Docker之旅-CentOS7中安装Docker]]></title>
    <url>%2F2017%2F03%2F24%2F170324-Docker%E4%B9%8B%E6%97%85-CentOS7%E4%B8%AD%E5%AE%89%E8%A3%85Docker%2F</url>
    <content type="text"><![CDATA[CentOS7中安装Docker服务支持 yum update1$ sudo yum update Get Docker CE on CentOSYou can install Docker CE on CentOS in just three steps.Enterprise customers can also install Docker EE for CentOS.Prerequisites Docker CE is supported on CentOS 7.3 64-bit. 1. Set up the repositorySet up the Docker CE repository on CentOS: 1234567$ sudo yum install -y yum-utils$ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo$ sudo yum makecache fast 2. Get Docker CEInstall the latest version of Docker CE on CentOS:1$ sudo yum -y install docker-ce Start Docker:1$ sudo systemctl start docker 3. Test your Docker CE installationTest your installation:1$ sudo docker run hello-world 设置为开机自启1$ sudo chkconfig docker on]]></content>
      <categories>
        <category>微服务</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker之旅-介绍]]></title>
    <url>%2F2017%2F03%2F24%2F170324-Docker%E4%B9%8B%E6%97%85-%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Docker是什么Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口,自2013年发行以来此项虚拟化容器技术得到了广泛发展。 从2016年Docker明确了将会在企业级方面重点跟进，2017年3月之后Docker分为两个版本Docker Community Edition(docker-ce)、Docker Enterprise Edition(docker-ee) CE与EE区别 收费方式 土豪伙伴土豪小伙伴早已跟上]]></content>
      <categories>
        <category>微服务</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 介绍]]></title>
    <url>%2F2017%2F03%2F18%2F170318-Linux-%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持[32位]和[64位]硬件。Linux继承了[Unix]以[网络]为核心的设计思想，是一个性能稳定的多用户网络操作系统 Linux介绍Linux核心理念：万物皆目录文件Linux: 是一个内核，而不是一个操作系统；因此我们平时常说的“操作系统是 Windows\Mac还是Linux?作者芬兰研究生 LINUSUnix Like : 很像Unix的操作系统 Linux学习方法 做笔记 多实验 理解记忆 Linux优点 开放的学习环境 漏洞快速修补 内核只有几百K，适合嵌入式 Linux缺点 有些专业软件没有Linux版本 Linux 分支 Redhat centos 2014 被红帽收购 XFS文件系统 Fedora 红帽公司的桌面版 中国红旗 RHCE redhat考题全英文 从事工作1、linux运维2、运维开发3、mysqlDBA4、安全运维5、大数据运维云计算运维6、架构师]]></content>
      <categories>
        <category>架构师</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1024 程序猿们的节日礼物？]]></title>
    <url>%2F2016%2F10%2F24%2F161024-%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%BB%AC%E7%9A%84%E8%8A%82%E6%97%A5%2F</url>
    <content type="text"><![CDATA[今天1024了，虽然刚从安吉游玩回来，拖着疲惫的身体，但任然想着是不是能为程序猿朋友们谋求些节日礼物，这是怎样一种精神，O(∩_∩)O哈哈~在这里先祝程序员们，节日快乐！什么是程序猿们最想要的节日礼物呢？HTML贺卡？鼠标键盘？耳机？各种智能设备？女朋友？好吧，打开siri 来个妞吧，然而，竟然她也无能为力，呵呵，能够把握机会的程序猿回这么跟自己❤️爱的妹子说： 1024了你该给我个礼物了吧！扯个淡，各位晚安😁！]]></content>
      <categories>
        <category>其他</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>1024</tag>
        <tag>节日</tag>
        <tag>程序猿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十一假期随笔]]></title>
    <url>%2F2016%2F10%2F04%2F161004-%E5%8D%81%E4%B8%80%E5%81%87%E6%9C%9F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[开心假期，不谈枯燥的技术，只谈风月 O(∩_∩)O~国庆长假回到我那亲爱的家乡中国茧都-东台富安。这里盛产桑蚕，这里有特色的鱼汤面。这里有我最思恋的亲人，有我亲梅逐马的“情人”。虽然目“堵”了一路的回家车队壮观，也难没灭回家的热情。此时正当是秋蚕上山结茧的时候，父母们已忙的昏天黑地。作为都是农民的父母，是通过养蚕来供我上学读书，所以对于蚕总是有种特殊的感情！养蚕的辛苦，只有养蚕人才能体会，假期了回家看看，看看鬓发日益霜白的父亲母亲，看看可爱的蚕宝宝！看看即将丰收的稻田，看看久未联络的亲人朋友！ 祝富（gui）安（kang）！ Alex · 富安]]></content>
      <categories>
        <category>其他</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>十一</tag>
        <tag>假期</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb整合Discuz实现单点登录]]></title>
    <url>%2F2016%2F09%2F26%2F160926-JavaWeb%E6%95%B4%E5%90%88Discuz%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[为了丰富员工业余生活，增多交流机会，于是在公司搭建了论坛方便大家灌水，目前公司中企业级应用是基于JAVAEE的产品，论坛选用了比较受欢迎的Discuz 3.2, 为了避免二次登陆使用单点登陆解决，虽然查找了各种资料做集成，但是其中还是遇到了些问题，翻墙发现了：discuz-ucenter-api-for-java因为被墙，在国内无法访问code.google.com，已将测试代码做了部分调整上传至GitHub:https://github.com/yaonew/discuz-ucenter_api_for_java 第一步配置config.properties12345UC_API = http://你的discuz地址/uc_server 如http://localhost/bbs/uc_serverUC_IP = 正常情况下留空即可UC_KEY = N3M117R45aWfqfe4xcu0OfTcAT3r4K6f2KRoUOFYT（与ucenter通信的密钥，这里自己设定，需与discuz ucenter 一致）UC_APPID = 2 //appID为UCenter中应用管理中的ID，见UCenter设置UC_CONNECT = 正常情况下留空即可 第二步 配置web.xml,添加如下123456789&lt;servlet&gt; &lt;servlet-name&gt;api&lt;/servlet-name&gt; &lt;servlet-class&gt;com.fivestars.interfaces.bbs.api.UC&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;api&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/uc.php&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 第三步 配置ucenter管理员登陆UCenter : http://localhost/bbs/uc_server应用管理-&gt; 添加应用, 这边添加的应用ID，通信秘钥与第一步的配置保持一致配置完成，看到通信成功的信息，表示ucenter集成配置OK 第四步 访问测试页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;%@page import="java.util.LinkedList"%&gt;&lt;%@page import="com.fivestars.interfaces.bbs.util.XMLHelper"%&gt;&lt;%@page import="com.fivestars.interfaces.bbs.client.Client"%&gt;&lt;%Client uc = new Client();//String result1 = uc.uc_user_register("test3", "test3", "test3@huaqi.info");//out.println("xxx" + result1);String result = uc.uc_user_login("test3", "test3");LinkedList&lt;String&gt; rs = XMLHelper.uc_unserialize(result);if(rs.size()&gt;0)&#123; int $uid = Integer.parseInt(rs.get(0)); String $username = rs.get(1); String $password = rs.get(2); String $email = rs.get(3); if($uid &gt; 0) &#123; response.addHeader("P3P"," CP=\"CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR\""); out.println("登录成功"); out.println($username); out.println($password); out.println($email); String $ucsynlogin = uc.uc_user_synlogin($uid); out.println("登录成功"+$ucsynlogin); //本地登陆代码 //TODO ... .... Cookie auth = new Cookie("auth", uc.uc_authcode($password+"\t"+$uid, "ENCODE")); auth.setMaxAge(31536000); //auth.setDomain("localhost"); response.addCookie(auth); Cookie user = new Cookie("uchome_loginuser", $username); response.addCookie(user); &#125; else if($uid == -1) &#123; out.println("用户不存在,或者被删除"); &#125; else if($uid == -2) &#123; out.println("密码错"); &#125; else &#123; out.println("未定义"); &#125;&#125;else&#123; out.println("Login failed"); System.out.println(result);&#125; %&gt; 访问页面返回一段js：登录成功test3test3test3@huaqi.info登录成功 1&lt;script type="text/javascript" src="http://localhost/api/uc.php?time=1474188863&amp;amp;code=6dfdhvNXKRoUOFYTR3Jn3ORQ2LKDd6cI6X5p4RD3yxyh6gy3%2F%2FQAJ5u8URp7qR%2F%2F0jaIoha2g4MnGRtosanyDihDy%2BIyW0zNNAnjkGHoaC1uyga5U2py%2F6%2F4uolQKBJaVI%2FMsM%2BuFUlttWcSmS7mzQoN%2Be0tzvPFZg2Y" reload=“1”&lt;/script&gt; 在浏览器中执行后访问 discus已保持登陆状态！]]></content>
      <categories>
        <category>其他</category>
        <category>论坛</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>discuz</tag>
        <tag>php</tag>
        <tag>单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建GitHub个人博客系统]]></title>
    <url>%2F2016%2F09%2F20%2F160920-Hexo%E6%90%AD%E5%BB%BAGitHub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[作为一名征战于IT行业多年的程序猴，之前都本着拿来主义的原则，吸收互联网上各种知识，资料文档，很少写过博文分享，真是惭愧，想来也是本人比较懒得原因，最近突然心血来潮，写点什么供大家分享也是极好的，先就将Hexo个人博客搭建于GitHub上作一记录，给想要搭建个人博客的宝宝们一个参考，文采有限，凑合着看吧。 Hexohexo是一款基于Node.js的静态博客框架。目前在GitHub上已有12121 star 和 1953 fork。 安装GitGit是神马，Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。……不用啰嗦了百度上多有，我们的博客系统是开源与GitHub上的，以及我们最终部署在GitHub上，需要用到Git这个工具。下载对应的系统的版本安装包，我这边以window为例，下载地址：https://git-scm.com/downloads/ 下载到git-xxx.exe安装包双击安装 下一步…下一步…安装完验证Git是否安装正确，cmd打开dos窗口，输入：git –version是否能打印出git版本，正常输出表示安装成功！ 12C:\Users\peekay&gt; git --version git version2.9.0.windows.1 安装Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。hexo是一款基于Node.js的静态博客框架，显然需要Node.js的支持登陆Node.js中文网地址：http://nodejs.cn/ 下载对应系统版本，双击安装 下一步…安装完成，cmd打开dos窗口，输入：node -v 正常输出表示安装成功！ 12C:\Users\peekay&gt; node -v v4.4.7 注册GitHub账号及设置登陆GitHub官网 https://github.com/ 有账号的使用账号登陆，没有的创建一个，具体不啰嗦，网上教程一堆，下一步下一步注册完成。 一、设置git的username，email,打开Git目录下的Git Bash，输入：123$ git config --global user.name "peekay"$ git config --global user.email "peekay@sina.cn" 二、生成秘钥在Git Bash 中输入: ssh-keygen 一路回车 123456789101112131415161718192021$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/c/Users/peeka/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/peeka/.ssh/id_rsa.Your public key has been saved in /c/Users/peeka/.ssh/id_rsa.pub.The key fingerprint is:SHA256:u7Gm0/gYNWECusxcTmryX9BKNeGMUaFmVq3a/7Gjc4U peeka@DESKTOP-ANIM9KSThe key's randomart image is:+---[RSA 2048]----+| o.=o || . O .. || . O *.o || + X o.+ . ||. B +o. S . || + ..o.. oE . || . . o+o .. || . .oo=+oo || . o===o. |+----[SHA256]-----+ 最终的秘钥文件生成在用户家目录下的.ssh目录下。 三、将秘钥添加至GitHub用之前注册的账号登陆GitHub,Settings-&gt;SSH and GPG keys 点击 New SSH key, 将上一步家目录下.ssh/id_rsa.pub中的内容全部拷贝贴到key栏中，保存 四、新建仓库用于存放我们的博客Createa new repository 这里以 我们的用户名.github.io 安装Hexo程序进入Hexo官网 http://hexo.io 官网有详细的安装教程，若访问慢或压根打不开，还是国内你懂得，选择一个路径这里我们以E:为例 cmd到E盘，依次执行如下命令 12345678C:\Users\peekay&gt;e:E:\&gt;npm install hexo-cli -gE:\&gt;hexo init blogE:\&gt;cd blogE:\blog&gt;npm installE:\blog&gt;hexo serverINFO Start processingINFO Hexo is running at http://127.0.0.1:4000/. Press Ctrl+C to stop. 浏览器访问：http://127.0.0.1:4000 表示Hexo安装成功 将Hexo发布到GitHub配置Hexo编辑器打开E盘blog目录下的_config.yml文件 1234567891011121314151617# Site 设置站点标题 语言等信息title: Alex.Yao's Blogsubtitle:description:author: Alex.Yaolanguage: zh-Hanstimezone:.....# Deployment 配置git部署信息## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepository: https://github.com/yaonew/yaonew.github.io.gitbranch: master 部署Hexo 至GitHubcmd进入E盘blog目录 依次执行 12345E:\blog&gt;hexo cleanINFO Deleted database.E:\blog&gt;hexo generate .....E:\blog&gt;hexo deploy OK这样我们的博客系统就已经部署到GitHub上了，设置GitHub Pages这样我们的博客就可以通过 http://用户名.github.io访问了。 更换博客模版及相关的设置，当你如上的设置都OK的话，应该不难了，有机会我再补充有关模版更换设置等。就这样了，有什么问题可以给我留言。]]></content>
      <categories>
        <category>其他</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>hexo</tag>
        <tag>Git</tag>
        <tag>Node.js</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F09%2F16%2F160916-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
